"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCssVars = exports.useStyleCssClasses = exports.createSourceFile = void 0;
const vue_code_gen_1 = require("@volar/vue-code-gen");
const refSugarRanges_1 = require("@volar/vue-code-gen/out/parsers/refSugarRanges");
const scriptRanges_1 = require("@volar/vue-code-gen/out/parsers/scriptRanges");
const scriptSetupRanges_1 = require("@volar/vue-code-gen/out/parsers/scriptSetupRanges");
const compiler_sfc_1 = require("@vue/compiler-sfc");
const reactivity_1 = require("@vue/reactivity");
const sourceMaps_1 = require("./utils/sourceMaps");
const string_1 = require("./utils/string");
const templateGen = require("@volar/vue-code-gen/out/generators/template");
const parseCssClassNames_1 = require("./utils/parseCssClassNames");
const parseCssVars_1 = require("./utils/parseCssVars");
const file_vue_1 = require("./plugins/file-vue");
const file_md_1 = require("./plugins/file-md");
const file_html_1 = require("./plugins/file-html");
const vue_template_html_1 = require("./plugins/vue-template-html");
const vue_template_pug_1 = require("./plugins/vue-template-pug");
const vue_sfc_styles_1 = require("./plugins/vue-sfc-styles");
const vue_sfc_customblocks_1 = require("./plugins/vue-sfc-customblocks");
const vue_sfc_scripts_1 = require("./plugins/vue-sfc-scripts");
const vue_sfc_template_1 = require("./plugins/vue-sfc-template");
const vue_typescript_scripts_1 = require("./plugins/vue-typescript-scripts");
const vue_typescript_template_1 = require("./plugins/vue-typescript-template");
const source_map_1 = require("@volar/source-map");
;
function createSourceFile(fileName, _content, compilerOptions, vueCompilerOptions, ts, extraPlugins = []) {
    // refs
    const fileContent = (0, reactivity_1.ref)('');
    const sfc = (0, reactivity_1.reactive)({
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: [],
    }) /* avoid Sfc unwrap in .d.ts by reactive */;
    // use
    const compiledVue = (0, reactivity_1.computed)(() => {
        var _a;
        for (const plugin of plugins) {
            const compiled = (_a = plugin.compileFileToVue) === null || _a === void 0 ? void 0 : _a.call(plugin, fileName, fileContent.value);
            if (compiled) {
                return compiled;
            }
        }
        // given dummy result to avoid language server throw
        return {
            vue: '<template></template>',
            mappings: [],
        };
    });
    const vueContent = (0, reactivity_1.computed)(() => { var _a; return (_a = compiledVue.value) === null || _a === void 0 ? void 0 : _a.vue; });
    const parsedSfc = (0, reactivity_1.computed)(() => vueContent.value !== undefined ? (0, compiler_sfc_1.parse)(vueContent.value, { sourceMap: false, ignoreEmpty: false }) : undefined);
    const computedHtmlTemplate = (0, reactivity_1.computed)(() => {
        var _a;
        if (sfc.template) {
            for (const plugin of plugins) {
                const compiledHtml = (_a = plugin.compileTemplateToHtml) === null || _a === void 0 ? void 0 : _a.call(plugin, sfc.template.lang, sfc.template.content);
                if (compiledHtml) {
                    return compiledHtml;
                }
                ;
            }
        }
    });
    const templateAstCompiled = (0, reactivity_1.computed)(() => {
        var _a;
        if (computedHtmlTemplate.value) {
            return (0, vue_code_gen_1.compileSFCTemplate)(computedHtmlTemplate.value.html, vueCompilerOptions.experimentalTemplateCompilerOptions, (_a = vueCompilerOptions.target) !== null && _a !== void 0 ? _a : 3);
        }
    });
    const cssModuleClasses = useStyleCssClasses(sfc, style => !!style.module);
    const cssScopedClasses = useStyleCssClasses(sfc, style => {
        var _a;
        const setting = (_a = compilerOptions.experimentalResolveStyleCssClasses) !== null && _a !== void 0 ? _a : 'scoped';
        return (setting === 'scoped' && style.scoped) || setting === 'always';
    });
    const templateCodeGens = (0, reactivity_1.computed)(() => {
        var _a, _b, _c, _d, _e, _f;
        if (!computedHtmlTemplate.value)
            return;
        if (!((_a = templateAstCompiled.value) === null || _a === void 0 ? void 0 : _a.ast))
            return;
        return templateGen.generate(ts, {
            target: (_b = vueCompilerOptions.target) !== null && _b !== void 0 ? _b : 3,
            strictTemplates: (_c = vueCompilerOptions.strictTemplates) !== null && _c !== void 0 ? _c : false,
            experimentalRuntimeMode: vueCompilerOptions.experimentalRuntimeMode,
            experimentalAllowTypeNarrowingInInlineHandlers: (_d = vueCompilerOptions.experimentalAllowTypeNarrowingInInlineHandlers) !== null && _d !== void 0 ? _d : false,
        }, (_f = (_e = sfc.template) === null || _e === void 0 ? void 0 : _e.lang) !== null && _f !== void 0 ? _f : 'html', templateAstCompiled.value.ast, !!sfc.scriptSetup, Object.values(cssScopedClasses.value).map(style => style.classNames).flat(), computedHtmlTemplate.value.mapping, {
            getEmitCompletion: string_1.SearchTexts.EmitCompletion,
            getPropsCompletion: string_1.SearchTexts.PropsCompletion,
        });
    });
    const cssVars = useCssVars(sfc);
    const cssVarTexts = (0, reactivity_1.computed)(() => {
        const result = [];
        for (const { style, ranges } of cssVars.value) {
            for (const range of ranges) {
                result.push(style.content.substring(range.start, range.end));
            }
        }
        return result;
    });
    const scriptAst = (0, reactivity_1.computed)(() => {
        if (sfc.script) {
            return ts.createSourceFile(fileName + '.' + sfc.script.lang, sfc.script.content, ts.ScriptTarget.Latest);
        }
    });
    const scriptSetupAst = (0, reactivity_1.computed)(() => {
        if (sfc.scriptSetup) {
            return ts.createSourceFile(fileName + '.' + sfc.scriptSetup.lang, sfc.scriptSetup.content, ts.ScriptTarget.Latest);
        }
    });
    const scriptRanges = (0, reactivity_1.computed)(() => scriptAst.value
        ? (0, scriptRanges_1.parseScriptRanges)(ts, scriptAst.value, !!sfc.scriptSetup, false, false)
        : undefined);
    const scriptSetupRanges = (0, reactivity_1.computed)(() => scriptSetupAst.value
        ? (0, scriptSetupRanges_1.parseScriptSetupRanges)(ts, scriptSetupAst.value)
        : undefined);
    const scriptLang = (0, reactivity_1.computed)(() => {
        return !sfc.script && !sfc.scriptSetup ? 'ts'
            : sfc.scriptSetup && sfc.scriptSetup.lang !== 'js' ? sfc.scriptSetup.lang
                : sfc.script && sfc.script.lang !== 'js' ? sfc.script.lang
                    : 'js';
    });
    const sfcRefSugarRanges = (0, reactivity_1.computed)(() => (scriptSetupAst.value ? {
        refs: (0, refSugarRanges_1.parseRefSugarDeclarationRanges)(ts, scriptSetupAst.value, ['$ref', '$computed', '$shallowRef', '$fromRefs']),
        raws: (0, refSugarRanges_1.parseRefSugarCallRanges)(ts, scriptSetupAst.value, ['$raw', '$fromRefs']),
    } : undefined));
    const plugins = [
        ...extraPlugins,
        (0, file_vue_1.default)(),
        (0, file_md_1.default)(),
        (0, file_html_1.default)(),
        (0, vue_template_html_1.default)(),
        (0, vue_template_pug_1.default)(),
        (0, vue_sfc_styles_1.default)(),
        (0, vue_sfc_customblocks_1.default)(),
        (0, vue_sfc_scripts_1.default)(),
        (0, vue_sfc_template_1.default)(),
        (0, vue_typescript_scripts_1.default)(scriptLang, scriptRanges, scriptSetupRanges, templateCodeGens, vueCompilerOptions, cssVarTexts),
        (0, vue_typescript_template_1.default)(ts, cssModuleClasses, cssScopedClasses, templateCodeGens, cssVars, scriptSetupRanges, scriptLang, vueCompilerOptions, !!vueCompilerOptions.experimentalDisableTemplateSupport || compilerOptions.jsx !== ts.JsxEmit.Preserve, fileName.endsWith('.html') // petite-vue
        ),
    ];
    // computeds
    const file2VueSourceMap = (0, reactivity_1.computed)(() => {
        var _a, _b;
        return new source_map_1.SourceMapBase(((_b = (_a = compiledVue.value) === null || _a === void 0 ? void 0 : _a.mappings) !== null && _b !== void 0 ? _b : []).map(mapping => ({
            data: undefined,
            mode: source_map_1.Mode.Offset,
            sourceRange: {
                start: mapping.fileOffset,
                end: mapping.fileOffset + mapping.length,
            },
            mappedRange: {
                start: mapping.vueOffset,
                end: mapping.vueOffset + mapping.length,
            },
        })));
    });
    const pluginEmbeddeds = plugins.map(plugin => {
        if (plugin.getEmbeddedFilesCount && plugin.getEmbeddedFile) {
            const embeddedsCount = (0, reactivity_1.computed)(() => plugin.getEmbeddedFilesCount(fileName, sfc));
            const embeddeds = (0, reactivity_1.computed)(() => {
                const computeds = [];
                for (let i = 0; i < embeddedsCount.value; i++) {
                    const _i = i;
                    const raw = (0, reactivity_1.computed)(() => {
                        return plugin.getEmbeddedFile(fileName, sfc, _i);
                    });
                    const transformed = (0, reactivity_1.computed)(() => {
                        var _a, _b;
                        if (!raw.value)
                            return;
                        const newMappings = [];
                        for (const mapping of raw.value.mappings) {
                            const vueRange = embeddedRangeToVueRange(mapping.data, mapping.sourceRange);
                            const fileRange = (_a = file2VueSourceMap.value.getSourceRange(vueRange.start, vueRange.end)) === null || _a === void 0 ? void 0 : _a[0];
                            if (fileRange) {
                                let additional;
                                if (mapping.additional) {
                                    additional = [];
                                    for (const add of mapping.additional) {
                                        const addVueRange = embeddedRangeToVueRange(mapping.data, add.sourceRange);
                                        const addFileRange = (_b = file2VueSourceMap.value.getSourceRange(addVueRange.start, addVueRange.end)) === null || _b === void 0 ? void 0 : _b[0];
                                        if (addFileRange) {
                                            additional.push(Object.assign(Object.assign({}, add), { sourceRange: addFileRange }));
                                        }
                                    }
                                }
                                newMappings.push(Object.assign(Object.assign({}, mapping), { sourceRange: fileRange, additional }));
                            }
                            else if (compiledVue.value) {
                                // fix markdown template mapping failed
                                const inRangeMappings = compiledVue.value.mappings.filter(mapping => mapping.vueOffset >= vueRange.start && (mapping.vueOffset + mapping.length) <= vueRange.end);
                                for (const inRangeMapping of inRangeMappings) {
                                    const _vueRange = {
                                        start: inRangeMapping.vueOffset,
                                        end: inRangeMapping.vueOffset + inRangeMapping.length,
                                    };
                                    const _fileRange = {
                                        start: inRangeMapping.fileOffset,
                                        end: inRangeMapping.fileOffset + inRangeMapping.length,
                                    };
                                    const embedded = vueRangeToEmbeddedRange(mapping.data, _vueRange);
                                    newMappings.push(Object.assign(Object.assign({}, mapping), { sourceRange: _fileRange, mappedRange: embedded }));
                                }
                            }
                        }
                        const newSourceMap = new sourceMaps_1.EmbeddedFileSourceMap(newMappings);
                        const newEmbedded = {
                            file: raw.value,
                            sourceMap: newSourceMap,
                            teleport: new sourceMaps_1.Teleport(raw.value.teleportMappings),
                        };
                        return newEmbedded;
                    });
                    computeds.push(transformed);
                }
                return computeds;
            });
            return embeddeds;
        }
    }).filter(notEmpty);
    const embeddedVue = (0, reactivity_1.computed)(() => {
        if (!fileName.endsWith('.vue') && compiledVue.value) {
            const embeddedFile = {
                fileName: fileName + '.vue',
                content: compiledVue.value.vue,
                capabilities: {
                    diagnostics: true,
                    foldingRanges: false,
                    formatting: false,
                    documentSymbol: false,
                    codeActions: true,
                    inlayHints: true,
                },
                isTsHostFile: false,
                mappings: compiledVue.value.mappings.map(mapping => ({
                    data: {
                        vueTag: undefined,
                        capabilities: {
                            basic: true,
                            references: true,
                            definitions: true,
                            diagnostic: true,
                            rename: true,
                            completion: true,
                            semanticTokens: true,
                            referencesCodeLens: false,
                            displayWithLink: false,
                        },
                    },
                    mode: source_map_1.Mode.Offset,
                    sourceRange: {
                        start: mapping.fileOffset,
                        end: mapping.fileOffset + mapping.length,
                    },
                    mappedRange: {
                        start: mapping.vueOffset,
                        end: mapping.vueOffset + mapping.length,
                    },
                })),
            };
            const embedded = {
                file: embeddedFile,
                sourceMap: new sourceMaps_1.EmbeddedFileSourceMap(embeddedFile.mappings),
                teleport: undefined,
            };
            return embedded;
        }
    });
    const allEmbeddeds = (0, reactivity_1.computed)(() => {
        const all = [];
        if (embeddedVue.value) {
            all.push(embeddedVue.value);
        }
        for (const getEmbeddeds of pluginEmbeddeds) {
            for (const embedded of getEmbeddeds.value) {
                if (embedded.value) {
                    if (embeddedVue.value && !embedded.value.file.parentFileName) {
                        all.push(Object.assign(Object.assign({}, embedded.value), { file: Object.assign(Object.assign({}, embedded.value.file), { parentFileName: embeddedVue.value.file.fileName }) }));
                    }
                    else {
                        all.push(embedded.value);
                    }
                }
            }
        }
        return all;
    });
    const teleports = (0, reactivity_1.computed)(() => {
        const _all = [];
        for (const embedded of allEmbeddeds.value) {
            if (embedded.teleport) {
                _all.push({
                    file: embedded.file,
                    teleport: embedded.teleport,
                });
            }
        }
        return _all;
    });
    const embeddeds = (0, reactivity_1.computed)(() => {
        const embeddeds = [];
        let remain = [...allEmbeddeds.value];
        while (remain.length) {
            const beforeLength = remain.length;
            consumeRemain();
            if (beforeLength === remain.length) {
                break;
            }
        }
        for (const e of remain) {
            embeddeds.push({
                self: e,
                embeddeds: [],
            });
            // 	throw 'Unable to resolve embeddeds: ' + remain[0].parentFileName + ' -> ' + remain[0].file.fileName;
        }
        return embeddeds;
        function consumeRemain() {
            for (let i = remain.length - 1; i >= 0; i--) {
                const embedded = remain[i];
                if (!embedded.file.parentFileName) {
                    embeddeds.push({
                        self: embedded,
                        embeddeds: [],
                    });
                    remain.splice(i, 1);
                }
                else {
                    const parent = findParentStructure(embedded.file.parentFileName, embeddeds);
                    if (parent) {
                        parent.embeddeds.push({
                            self: embedded,
                            embeddeds: [],
                        });
                        remain.splice(i, 1);
                    }
                }
            }
        }
        function findParentStructure(fileName, strus) {
            var _a;
            for (const stru of strus) {
                if (((_a = stru.self) === null || _a === void 0 ? void 0 : _a.file.fileName) === fileName) {
                    return stru;
                }
                let _stru = findParentStructure(fileName, stru.embeddeds);
                if (_stru) {
                    return _stru;
                }
            }
        }
    });
    update(_content);
    return {
        fileName,
        get text() {
            return fileContent.value;
        },
        set text(value) {
            update(value);
        },
        getCompiledVue: () => file2VueSourceMap.value,
        getSfcTemplateLanguageCompiled: () => computedHtmlTemplate.value,
        getSfcVueTemplateCompiled: () => templateAstCompiled.value,
        getScriptFileName: () => fileName.endsWith('.html') ? fileName + '.__VLS_script.' + scriptLang.value : fileName + '.' + scriptLang.value,
        getDescriptor: () => (0, reactivity_1.unref)(sfc),
        getScriptAst: () => scriptAst.value,
        getScriptSetupAst: () => scriptSetupAst.value,
        getSfcRefSugarRanges: () => sfcRefSugarRanges.value,
        getEmbeddeds: () => embeddeds.value,
        getScriptSetupRanges: () => scriptSetupRanges.value,
        isJsxMissing: () => !vueCompilerOptions.experimentalDisableTemplateSupport && compilerOptions.jsx !== ts.JsxEmit.Preserve,
        getAllEmbeddeds: () => allEmbeddeds.value,
        getTeleports: () => teleports.value,
    };
    function embeddedRangeToVueRange(data, range) {
        var _a;
        if (vueContent.value === undefined)
            throw 'vueContent.value === undefined';
        if (data.vueTag === 'scriptSrc') {
            if (!((_a = sfc.script) === null || _a === void 0 ? void 0 : _a.src))
                throw '!sfc.script?.src';
            const vueStart = vueContent.value.substring(0, sfc.script.startTagEnd).lastIndexOf(sfc.script.src);
            const vueEnd = vueStart + sfc.script.src.length;
            return {
                start: vueStart - 1,
                end: vueEnd + 1,
            };
        }
        else if (data.vueTag === 'script') {
            if (!sfc.script)
                throw '!sfc.script';
            return {
                start: range.start + sfc.script.startTagEnd,
                end: range.end + sfc.script.startTagEnd,
            };
        }
        else if (data.vueTag === 'scriptSetup') {
            if (!sfc.scriptSetup)
                throw '!sfc.scriptSetup';
            return {
                start: range.start + sfc.scriptSetup.startTagEnd,
                end: range.end + sfc.scriptSetup.startTagEnd,
            };
        }
        else if (data.vueTag === 'template') {
            if (!sfc.template)
                throw '!sfc.template';
            return {
                start: range.start + sfc.template.startTagEnd,
                end: range.end + sfc.template.startTagEnd,
            };
        }
        else if (data.vueTag === 'style') {
            if (data.vueTagIndex === undefined)
                throw 'data.vueTagIndex === undefined';
            return {
                start: range.start + sfc.styles[data.vueTagIndex].startTagEnd,
                end: range.end + sfc.styles[data.vueTagIndex].startTagEnd,
            };
        }
        else if (data.vueTag === 'customBlock') {
            if (data.vueTagIndex === undefined)
                throw 'data.vueTagIndex === undefined';
            return {
                start: range.start + sfc.customBlocks[data.vueTagIndex].startTagEnd,
                end: range.end + sfc.customBlocks[data.vueTagIndex].startTagEnd,
            };
        }
        return range;
    }
    function vueRangeToEmbeddedRange(data, range) {
        if (vueContent.value === undefined)
            throw 'vueContent.value === undefined';
        if (data.vueTag === 'script') {
            if (!sfc.script)
                throw '!sfc.script';
            return {
                start: range.start - sfc.script.startTagEnd,
                end: range.end - sfc.script.startTagEnd,
            };
        }
        else if (data.vueTag === 'scriptSetup') {
            if (!sfc.scriptSetup)
                throw '!sfc.scriptSetup';
            return {
                start: range.start - sfc.scriptSetup.startTagEnd,
                end: range.end - sfc.scriptSetup.startTagEnd,
            };
        }
        else if (data.vueTag === 'template') {
            if (!sfc.template)
                throw '!sfc.template';
            return {
                start: range.start - sfc.template.startTagEnd,
                end: range.end - sfc.template.startTagEnd,
            };
        }
        else if (data.vueTag === 'style') {
            if (data.vueTagIndex === undefined)
                throw 'data.vueTagIndex === undefined';
            return {
                start: range.start - sfc.styles[data.vueTagIndex].startTagEnd,
                end: range.end - sfc.styles[data.vueTagIndex].startTagEnd,
            };
        }
        else if (data.vueTag === 'customBlock') {
            if (data.vueTagIndex === undefined)
                throw 'data.vueTagIndex === undefined';
            return {
                start: range.start - sfc.customBlocks[data.vueTagIndex].startTagEnd,
                end: range.end - sfc.customBlocks[data.vueTagIndex].startTagEnd,
            };
        }
        return range;
    }
    function update(newContent) {
        if (fileContent.value === newContent)
            return;
        fileContent.value = newContent;
        // TODO: wait for https://github.com/vuejs/core/pull/5912
        if (parsedSfc.value) {
            updateTemplate(parsedSfc.value.descriptor.template);
            updateScript(parsedSfc.value.descriptor.script);
            updateScriptSetup(parsedSfc.value.descriptor.scriptSetup);
            updateStyles(parsedSfc.value.descriptor.styles);
            updateCustomBlocks(parsedSfc.value.descriptor.customBlocks);
        }
        function updateTemplate(block) {
            var _a;
            const newData = block ? {
                tag: 'template',
                start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                startTagEnd: block.loc.start.offset,
                endTagStart: block.loc.end.offset,
                content: block.content,
                lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'html',
            } : null;
            if (sfc.template && newData) {
                updateBlock(sfc.template, newData);
            }
            else {
                sfc.template = newData;
            }
        }
        function updateScript(block) {
            var _a;
            const newData = block ? {
                tag: 'script',
                start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                startTagEnd: block.loc.start.offset,
                endTagStart: block.loc.end.offset,
                content: block.content,
                lang: getValidScriptSyntax((_a = block.lang) !== null && _a !== void 0 ? _a : 'js'),
                src: block.src,
            } : null;
            if (sfc.script && newData) {
                updateBlock(sfc.script, newData);
            }
            else {
                sfc.script = newData;
            }
        }
        function updateScriptSetup(block) {
            var _a;
            const newData = block ? {
                tag: 'scriptSetup',
                start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                startTagEnd: block.loc.start.offset,
                endTagStart: block.loc.end.offset,
                content: block.content,
                lang: getValidScriptSyntax((_a = block.lang) !== null && _a !== void 0 ? _a : 'js'),
            } : null;
            if (sfc.scriptSetup && newData) {
                updateBlock(sfc.scriptSetup, newData);
            }
            else {
                sfc.scriptSetup = newData;
            }
        }
        function updateStyles(blocks) {
            var _a;
            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];
                const newData = {
                    tag: 'style',
                    start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                    end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                    startTagEnd: block.loc.start.offset,
                    endTagStart: block.loc.end.offset,
                    content: block.content,
                    lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'css',
                    module: typeof block.module === 'string' ? block.module : block.module ? '$style' : undefined,
                    scoped: !!block.scoped,
                };
                if (sfc.styles.length > i) {
                    updateBlock(sfc.styles[i], newData);
                }
                else {
                    sfc.styles.push(newData);
                }
            }
            while (sfc.styles.length > blocks.length) {
                sfc.styles.pop();
            }
        }
        function updateCustomBlocks(blocks) {
            var _a;
            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];
                const newData = {
                    tag: 'customBlock',
                    start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                    end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                    startTagEnd: block.loc.start.offset,
                    endTagStart: block.loc.end.offset,
                    content: block.content,
                    lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'txt',
                    type: block.type,
                };
                if (sfc.customBlocks.length > i) {
                    updateBlock(sfc.customBlocks[i], newData);
                }
                else {
                    sfc.customBlocks.push(newData);
                }
            }
            while (sfc.customBlocks.length > blocks.length) {
                sfc.customBlocks.pop();
            }
        }
        function updateBlock(oldBlock, newBlock) {
            for (let key in newBlock) {
                oldBlock[key] = newBlock[key];
            }
        }
    }
}
exports.createSourceFile = createSourceFile;
function useStyleCssClasses(sfc, condition) {
    return (0, reactivity_1.computed)(() => {
        const result = [];
        for (let i = 0; i < sfc.styles.length; i++) {
            const style = sfc.styles[i];
            if (condition(style)) {
                const classNameRanges = [...(0, parseCssClassNames_1.parseCssClassNames)(style.content)];
                result.push({
                    style: style,
                    index: i,
                    classNameRanges: classNameRanges,
                    classNames: classNameRanges.map(range => style.content.substring(range.start + 1, range.end)),
                });
            }
        }
        return result;
    });
}
exports.useStyleCssClasses = useStyleCssClasses;
function useCssVars(sfc) {
    return (0, reactivity_1.computed)(() => {
        const result = [];
        for (let i = 0; i < sfc.styles.length; i++) {
            const style = sfc.styles[i];
            result.push({
                style: style,
                styleIndex: i,
                ranges: [...(0, parseCssVars_1.parseCssVars)(style.content)],
            });
        }
        return result;
    });
}
exports.useCssVars = useCssVars;
const validScriptSyntaxs = ['js', 'jsx', 'ts', 'tsx'];
function getValidScriptSyntax(syntax) {
    if (validScriptSyntaxs.includes(syntax)) {
        return syntax;
    }
    return 'js';
}
function notEmpty(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=sourceFile.js.map
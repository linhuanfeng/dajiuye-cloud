"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const code_gen_1 = require("@volar/code-gen");
const SourceMaps = require("@volar/source-map");
const vue_code_gen_1 = require("@volar/vue-code-gen");
const transform_1 = require("@volar/vue-code-gen/out/transform");
const path_1 = require("path");
const string_1 = require("../utils/string");
function default_1(ts, cssModuleClasses, cssScopedClasses, templateCodeGens, cssVars, scriptSetupRanges, scriptLang, compilerOptions, disableTemplateScript, useGlobalThisTypeInCtx) {
    return {
        getEmbeddedFilesCount(fileName, sfc) {
            return 3;
        },
        getEmbeddedFile(fileName, sfc, i) {
            var _a, _b, _c, _d, _e, _f;
            const baseFileName = path_1.posix.basename(fileName);
            if (i === 0 && !disableTemplateScript) {
                let scriptLeadingComments = [];
                if ((_a = compilerOptions.experimentalUseScriptLeadingCommentInTemplate) !== null && _a !== void 0 ? _a : true) {
                    for (const _script of [sfc.script, sfc.scriptSetup]) {
                        if (_script) {
                            const commentRanges = ts.getLeadingCommentRanges(_script.content, 0);
                            if (commentRanges) {
                                scriptLeadingComments = commentRanges.map(range => _script.content.substring(range.pos, range.end));
                            }
                        }
                    }
                }
                const scriptLeadingComment = scriptLeadingComments.join('\n');
                const tsxCodeGen = new code_gen_1.CodeGen();
                tsxCodeGen.addText(scriptLeadingComment + '\n');
                tsxCodeGen.addText(`import * as __VLS_types from './__VLS_types';\n`);
                if (sfc.script || sfc.scriptSetup) {
                    tsxCodeGen.addText(`import { __VLS_options, __VLS_name } from './${baseFileName}.__VLS_script';\n`);
                    tsxCodeGen.addText(`import __VLS_component from './${baseFileName}.__VLS_script';\n`);
                }
                else {
                    tsxCodeGen.addText(`var __VLS_name = undefined;\n`);
                    tsxCodeGen.addText(`var __VLS_options = {};\n`);
                    tsxCodeGen.addText(`var __VLS_component = (await import('${(0, vue_code_gen_1.getVueLibraryName)((_b = compilerOptions.target) !== null && _b !== void 0 ? _b : 3)}')).defineComponent({});\n`);
                }
                writeImportTypes();
                tsxCodeGen.addText(`declare var __VLS_ctx: ${useGlobalThisTypeInCtx ? 'typeof globalThis &' : ''} InstanceType<__VLS_types.PickNotAny<typeof __VLS_component, new () => {}>> & {\n`);
                /* CSS Module */
                for (const cssModule of cssModuleClasses.value) {
                    tsxCodeGen.addText(`${cssModule.style.module}: Record<string, string>`);
                    for (const classNameRange of cssModule.classNameRanges) {
                        writeCssClassProperty(cssModule.index, cssModule.style.content.substring(classNameRange.start + 1, classNameRange.end), classNameRange, 'string', false);
                    }
                    tsxCodeGen.addText(';\n');
                }
                tsxCodeGen.addText(`};\n`);
                tsxCodeGen.addText(`declare var __VLS_vmUnwrap: typeof __VLS_options & { components: { } };\n`);
                /* Components */
                tsxCodeGen.addText('/* Components */\n');
                tsxCodeGen.addText('declare var __VLS_otherComponents: NonNullable<typeof __VLS_component extends { components: infer C } ? C : {}> & __VLS_types.GlobalComponents & typeof __VLS_vmUnwrap.components & __VLS_types.PickComponents<typeof __VLS_ctx>;\n');
                tsxCodeGen.addText(`declare var __VLS_selfComponent: __VLS_types.SelfComponent<typeof __VLS_name, typeof __VLS_component & (new () => { ${(0, vue_code_gen_1.getSlotsPropertyName)((_c = compilerOptions.target) !== null && _c !== void 0 ? _c : 3)}: typeof __VLS_slots })>;\n`);
                tsxCodeGen.addText('declare var __VLS_components: typeof __VLS_otherComponents & Omit<typeof __VLS_selfComponent, keyof typeof __VLS_otherComponents>;\n');
                tsxCodeGen.addText(`__VLS_components.${string_1.SearchTexts.Components};\n`);
                tsxCodeGen.addText(`({} as __VLS_types.GlobalAttrs).${string_1.SearchTexts.GlobalAttrs};\n`);
                /* Style Scoped */
                tsxCodeGen.addText('/* Style Scoped */\n');
                tsxCodeGen.addText('type __VLS_StyleScopedClasses = {}');
                for (const scopedCss of cssScopedClasses.value) {
                    for (const classNameRange of scopedCss.classNameRanges) {
                        writeCssClassProperty(scopedCss.index, scopedCss.style.content.substring(classNameRange.start + 1, classNameRange.end), classNameRange, 'boolean', true);
                    }
                }
                tsxCodeGen.addText(';\n');
                tsxCodeGen.addText('declare var __VLS_styleScopedClasses: __VLS_StyleScopedClasses | keyof __VLS_StyleScopedClasses | (keyof __VLS_StyleScopedClasses)[];\n');
                tsxCodeGen.addText(`/* CSS variable injection */\n`);
                writeCssVars();
                if (templateCodeGens.value) {
                    (0, code_gen_1.mergeCodeGen)(tsxCodeGen, templateCodeGens.value.codeGen);
                }
                tsxCodeGen.addText(`export default __VLS_slots;\n`);
                const lang = scriptLang.value === 'js' ? 'jsx' : scriptLang.value === 'ts' ? 'tsx' : scriptLang.value;
                const embeddedFile = {
                    parentFileName: fileName + '.' + ((_d = sfc.template) === null || _d === void 0 ? void 0 : _d.lang),
                    fileName: fileName + '.__VLS_template.' + lang,
                    content: tsxCodeGen.getText(),
                    capabilities: {
                        diagnostics: true,
                        foldingRanges: false,
                        formatting: false,
                        documentSymbol: false,
                        codeActions: false,
                        inlayHints: true,
                    },
                    isTsHostFile: true,
                    mappings: tsxCodeGen.getMappings(),
                };
                return embeddedFile;
                function writeImportTypes() {
                    const bindingsArr = [];
                    if (scriptSetupRanges.value && sfc.scriptSetup) {
                        bindingsArr.push({
                            typeBindings: scriptSetupRanges.value.typeBindings,
                            content: sfc.scriptSetup.content,
                        });
                    }
                    // if (scriptRanges.value && script.value) {
                    // 	bindingsArr.push({
                    // 		typeBindings: scriptRanges.value.typeBindings,
                    // 		content: script.value.content,
                    // 	});
                    // }
                    tsxCodeGen.addText('import {\n');
                    for (const bindings of bindingsArr) {
                        for (const typeBinding of bindings.typeBindings) {
                            const text = bindings.content.substring(typeBinding.start, typeBinding.end);
                            tsxCodeGen.addText(`__VLS_types_${text} as ${text},\n`);
                        }
                    }
                    tsxCodeGen.addText(`} from './${baseFileName}.__VLS_script';\n`);
                }
                function writeCssClassProperty(styleIndex, className, classRange, propertyType, optional) {
                    tsxCodeGen.addText(`\n & { `);
                    tsxCodeGen.addMapping2({
                        mappedRange: {
                            start: tsxCodeGen.getText().length,
                            end: tsxCodeGen.getText().length + className.length + 2,
                        },
                        sourceRange: classRange,
                        mode: SourceMaps.Mode.Totally,
                        additional: [{
                                mappedRange: {
                                    start: tsxCodeGen.getText().length + 1,
                                    end: tsxCodeGen.getText().length + 1 + className.length,
                                },
                                sourceRange: classRange,
                                mode: SourceMaps.Mode.Offset,
                            }],
                        data: {
                            vueTag: 'style',
                            vueTagIndex: styleIndex,
                            capabilities: {
                                references: true,
                                rename: true,
                                referencesCodeLens: true,
                            },
                            normalizeNewName: beforeCssRename,
                            applyNewName: doCssRename,
                        },
                    });
                    tsxCodeGen.addText(`'${className}'${optional ? '?' : ''}: ${propertyType}`);
                    tsxCodeGen.addText(` }`);
                }
                function writeCssVars() {
                    const emptyLocalVars = {};
                    const identifiers = new Set();
                    for (const cssVar of cssVars.value) {
                        for (const cssBind of cssVar.ranges) {
                            (0, transform_1.walkInterpolationFragment)(ts, cssVar.style.content.substring(cssBind.start, cssBind.end), (frag, fragOffset, isJustForErrorMapping) => {
                                if (fragOffset === undefined) {
                                    tsxCodeGen.addText(frag);
                                }
                                else {
                                    tsxCodeGen.addCode(frag, {
                                        start: cssBind.start + fragOffset,
                                        end: cssBind.start + fragOffset + frag.length,
                                    }, SourceMaps.Mode.Offset, {
                                        vueTag: 'style',
                                        vueTagIndex: cssVar.styleIndex,
                                        capabilities: isJustForErrorMapping ? {
                                            diagnostic: true,
                                        } : {
                                            basic: true,
                                            references: true,
                                            definitions: true,
                                            diagnostic: true,
                                            rename: true,
                                            completion: true,
                                            semanticTokens: true,
                                        },
                                    });
                                }
                            }, emptyLocalVars, identifiers);
                            tsxCodeGen.addText(';\n');
                        }
                    }
                }
            }
            else if (i === 1 && templateCodeGens.value) {
                const lang = scriptLang.value === 'js' ? 'jsx' : scriptLang.value === 'ts' ? 'tsx' : scriptLang.value;
                const embeddedFile = {
                    parentFileName: fileName + '.' + ((_e = sfc.template) === null || _e === void 0 ? void 0 : _e.lang),
                    fileName: fileName + '.__VLS_template.format.' + lang,
                    content: templateCodeGens.value.formatCodeGen.getText(),
                    capabilities: {
                        diagnostics: false,
                        foldingRanges: false,
                        formatting: true,
                        documentSymbol: true,
                        codeActions: false,
                        inlayHints: false,
                    },
                    isTsHostFile: false,
                    mappings: templateCodeGens.value.formatCodeGen.getMappings(),
                };
                return embeddedFile;
            }
            else if (i === 2 && templateCodeGens.value) {
                const file = {
                    parentFileName: fileName + '.' + ((_f = sfc.template) === null || _f === void 0 ? void 0 : _f.lang),
                    fileName: fileName + '.template.css',
                    content: templateCodeGens.value.cssCodeGen.getText(),
                    capabilities: {
                        diagnostics: false,
                        foldingRanges: false,
                        formatting: false,
                        codeActions: false,
                        documentSymbol: false,
                        inlayHints: false,
                    },
                    isTsHostFile: false,
                    mappings: templateCodeGens.value.cssCodeGen.getMappings(),
                };
                return file;
            }
        },
    };
}
exports.default = default_1;
function beforeCssRename(newName) {
    return newName.startsWith('.') ? newName.slice(1) : newName;
}
function doCssRename(oldName, newName) {
    return '.' + newName;
}
//# sourceMappingURL=vue-typescript-template.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageServiceContext = void 0;
const path_1 = require("path");
const localTypes = require("./utils/localTypes");
const sourceFile_1 = require("./sourceFile");
const documentRegistry_1 = require("./documentRegistry");
function createLanguageServiceContext(ts, host, extraPlugins = [], exts = ['.vue', '.md', '.html']) {
    var _a;
    let lastProjectVersion;
    let tsProjectVersion = 0;
    const documentRegistry = (0, documentRegistry_1.createDocumentRegistry)();
    const compilerOptions = host.getCompilationSettings();
    const vueCompilerOptions = host.getVueCompilationSettings();
    const tsFileVersions = new Map();
    const sharedTypesScript = ts.ScriptSnapshot.fromString(localTypes.getTypesCode((_a = vueCompilerOptions.target) !== null && _a !== void 0 ? _a : 3));
    const scriptSnapshots = new Map();
    const fileVersions = new WeakMap();
    const _tsHost = {
        fileExists: host.fileExists
            ? fileName => {
                var _a, _b;
                const basename = path_1.posix.basename(fileName);
                if (basename === localTypes.typesFileName) {
                    return true;
                }
                // .vue.js -> .vue
                // .vue.ts -> .vue
                // .vue.d.ts (never)
                const vueFileName = fileName.substring(0, fileName.lastIndexOf('.'));
                if (exts.some(ext => vueFileName.endsWith(ext))) {
                    const vueFile = documentRegistry.get(vueFileName);
                    if (!vueFile) {
                        const fileExists = !!((_a = host.fileExists) === null || _a === void 0 ? void 0 : _a.call(host, vueFileName));
                        if (fileExists) {
                            // create virtual files
                            const scriptSnapshot = host.getScriptSnapshot(vueFileName);
                            if (scriptSnapshot) {
                                documentRegistry.set(vueFileName, (0, sourceFile_1.createSourceFile)(vueFileName, scriptSnapshot.getText(0, scriptSnapshot.getLength()), compilerOptions, vueCompilerOptions, ts, extraPlugins));
                            }
                        }
                    }
                }
                if (!!documentRegistry.fromEmbeddedFileName(fileName)) {
                    return true;
                }
                return !!((_b = host.fileExists) === null || _b === void 0 ? void 0 : _b.call(host, fileName));
            }
            : undefined,
        getProjectVersion: () => {
            return tsProjectVersion.toString();
        },
        getScriptFileNames,
        getScriptVersion,
        getScriptSnapshot,
        readDirectory: (_path, extensions, exclude, include, depth) => {
            var _a, _b;
            const result = (_b = (_a = host.readDirectory) === null || _a === void 0 ? void 0 : _a.call(host, _path, extensions, exclude, include, depth)) !== null && _b !== void 0 ? _b : [];
            for (const vuePath of documentRegistry.getFileNames()) {
                const vuePath2 = path_1.posix.join(_path, path_1.posix.basename(vuePath));
                if (path_1.posix.relative(_path.toLowerCase(), vuePath.toLowerCase()).startsWith('..')) {
                    continue;
                }
                if (!depth && vuePath.toLowerCase() === vuePath2.toLowerCase()) {
                    result.push(vuePath2);
                }
                else if (depth) {
                    result.push(vuePath2); // TODO: depth num
                }
            }
            return result;
        },
        getScriptKind(fileName) {
            if (exts.some(ext => fileName.endsWith(ext)))
                return ts.ScriptKind.TSX; // can't use External, Unknown
            switch (path_1.posix.extname(fileName)) {
                case '.js': return ts.ScriptKind.JS;
                case '.jsx': return ts.ScriptKind.JSX;
                case '.ts': return ts.ScriptKind.TS;
                case '.tsx': return ts.ScriptKind.TSX;
                case '.json': return ts.ScriptKind.JSON;
                default: return ts.ScriptKind.Unknown;
            }
        },
    };
    const tsHost = new Proxy(_tsHost, {
        get: (target, property) => {
            update();
            return target[property] || host[property];
        },
    });
    return {
        typescriptLanguageServiceHost: tsHost,
        typescriptLanguageService: ts.createLanguageService(tsHost),
        get sourceFiles() {
            update();
            return documentRegistry;
        },
    };
    function update() {
        var _a, _b;
        const newProjectVersion = (_a = host.getProjectVersion) === null || _a === void 0 ? void 0 : _a.call(host);
        const sholdUpdate = newProjectVersion === undefined || newProjectVersion !== lastProjectVersion;
        if (!sholdUpdate)
            return;
        lastProjectVersion = newProjectVersion;
        const fileNames = host.getScriptFileNames();
        const vueFileNames = new Set(fileNames.filter(file => exts.some(ext => file.endsWith(ext))));
        const tsFileNames = new Set(fileNames.filter(file => !exts.some(ext => file.endsWith(ext))));
        const fileNamesToRemove = [];
        const fileNamesToCreate = [];
        const fileNamesToUpdate = [];
        let tsFileUpdated = false;
        // .vue
        for (const vueFile of documentRegistry.getAll()) {
            const newSnapshot = host.getScriptSnapshot(vueFile.fileName);
            if (!newSnapshot) {
                // delete
                fileNamesToRemove.push(vueFile.fileName);
            }
            else {
                // update
                if (vueFile.text !== newSnapshot.getText(0, newSnapshot.getLength())) {
                    fileNamesToUpdate.push(vueFile.fileName);
                }
            }
        }
        for (const nowFileName of vueFileNames) {
            if (!documentRegistry.get(nowFileName)) {
                // add
                fileNamesToCreate.push(nowFileName);
            }
        }
        // .ts / .js / .d.ts / .json ...
        for (const tsFileVersion of tsFileVersions) {
            if (!vueFileNames.has(tsFileVersion[0]) && !((_b = host.fileExists) === null || _b === void 0 ? void 0 : _b.call(host, tsFileVersion[0]))) {
                // delete
                tsFileVersions.delete(tsFileVersion[0]);
                tsFileUpdated = true;
            }
            else {
                // update
                const newVersion = host.getScriptVersion(tsFileVersion[0]);
                if (tsFileVersion[1] !== newVersion) {
                    tsFileVersions.set(tsFileVersion[0], newVersion);
                    tsFileUpdated = true;
                }
            }
        }
        for (const nowFileName of tsFileNames) {
            if (!tsFileVersions.has(nowFileName)) {
                // add
                const newVersion = host.getScriptVersion(nowFileName);
                tsFileVersions.set(nowFileName, newVersion);
                tsFileUpdated = true;
            }
        }
        for (const uri of fileNamesToRemove) {
            if (documentRegistry.delete(uri)) {
                tsFileUpdated = true;
            }
        }
        for (const fileName of [
            ...fileNamesToCreate,
            ...fileNamesToUpdate,
        ]) {
            const scriptSnapshot = host.getScriptSnapshot(fileName);
            if (!scriptSnapshot) {
                continue;
            }
            const sourceFile = documentRegistry.get(fileName);
            const scriptText = scriptSnapshot.getText(0, scriptSnapshot.getLength());
            if (!sourceFile) {
                documentRegistry.set(fileName, (0, sourceFile_1.createSourceFile)(fileName, scriptText, compilerOptions, vueCompilerOptions, ts, extraPlugins));
                tsFileUpdated = true;
            }
            else {
                const oldScripts = {};
                const newScripts = {};
                if (!tsFileUpdated) {
                    for (const embedded of sourceFile.getAllEmbeddeds()) {
                        if (embedded.file.isTsHostFile) {
                            oldScripts[embedded.file.fileName] = embedded.file.content;
                        }
                    }
                }
                sourceFile.text = scriptText;
                if (!tsFileUpdated) {
                    for (const embedded of sourceFile.getAllEmbeddeds()) {
                        if (embedded.file.isTsHostFile) {
                            newScripts[embedded.file.fileName] = embedded.file.content;
                        }
                    }
                }
                if (Object.keys(oldScripts).length !== Object.keys(newScripts).length
                    || Object.keys(oldScripts).some(fileName => oldScripts[fileName] !== newScripts[fileName])) {
                    tsFileUpdated = true;
                }
            }
        }
        if (tsFileUpdated) {
            tsProjectVersion++;
        }
    }
    function getScriptFileNames() {
        const tsFileNames = documentRegistry.getDirs().map(dir => path_1.posix.join(dir, localTypes.typesFileName));
        for (const mapped of documentRegistry.getAllEmbeddeds()) {
            if (mapped.embedded.file.isTsHostFile) {
                tsFileNames.push(mapped.embedded.file.fileName); // virtual .ts
            }
        }
        for (const fileName of host.getScriptFileNames()) {
            if (host.isTsPlugin) {
                tsFileNames.push(fileName); // .vue + .ts
            }
            else if (!exts.some(ext => fileName.endsWith(ext))) {
                tsFileNames.push(fileName); // .ts
            }
        }
        return tsFileNames;
    }
    function getScriptVersion(fileName) {
        var _a, _b, _c;
        const basename = path_1.posix.basename(fileName);
        if (basename === localTypes.typesFileName) {
            return '';
        }
        let mapped = documentRegistry.fromEmbeddedFileName(fileName);
        if (mapped) {
            if (fileVersions.has(mapped.embedded.file)) {
                return fileVersions.get(mapped.embedded.file);
            }
            else {
                let version = (_c = (_b = (_a = ts.sys).createHash) === null || _b === void 0 ? void 0 : _b.call(_a, mapped.embedded.file.content)) !== null && _c !== void 0 ? _c : mapped.embedded.file.content;
                if (host.isTsc) {
                    // fix https://github.com/johnsoncodehk/volar/issues/1082
                    version = host.getScriptVersion(mapped.vueFile.fileName) + ':' + version;
                }
                fileVersions.set(mapped.embedded.file, version);
                return version;
            }
        }
        return host.getScriptVersion(fileName);
    }
    function getScriptSnapshot(fileName) {
        var _a;
        const basename = path_1.posix.basename(fileName);
        if (basename === localTypes.typesFileName) {
            return sharedTypesScript;
        }
        const version = getScriptVersion(fileName);
        const cache = scriptSnapshots.get(fileName.toLowerCase());
        if (cache && cache[0] === version) {
            return cache[1];
        }
        const mapped = documentRegistry.fromEmbeddedFileName(fileName);
        if (mapped) {
            const text = mapped.embedded.file.content;
            const snapshot = ts.ScriptSnapshot.fromString(text);
            scriptSnapshots.set(fileName.toLowerCase(), [version, snapshot]);
            return snapshot;
        }
        let tsScript = host.getScriptSnapshot(fileName);
        if (tsScript) {
            if (!((_a = vueCompilerOptions.strictTemplates) !== null && _a !== void 0 ? _a : false) && (
            // for vue 2.6 and vue 3
            basename === 'runtime-dom.d.ts' ||
                // for vue 2.7
                basename === 'jsx.d.ts')) {
                // allow arbitrary attributes
                let tsScriptText = tsScript.getText(0, tsScript.getLength());
                tsScriptText = tsScriptText.replace('type ReservedProps = {', 'type ReservedProps = { [name: string]: any');
                tsScript = ts.ScriptSnapshot.fromString(tsScriptText);
            }
            scriptSnapshots.set(fileName.toLowerCase(), [version, tsScript]);
            return tsScript;
        }
    }
}
exports.createLanguageServiceContext = createLanguageServiceContext;
//# sourceMappingURL=lsContext.js.map
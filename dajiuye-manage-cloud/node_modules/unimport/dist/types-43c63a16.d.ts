import MagicString from 'magic-string';

declare const builtinPresets: {
    '@vue/composition-api': Preset;
    '@vueuse/core': () => Preset;
    '@vueuse/head': Preset;
    pinia: Preset;
    preact: Preset;
    quasar: Preset;
    react: Preset;
    'react-router': Preset;
    'react-router-dom': Preset;
    svelte: Preset;
    'svelte/animate': Preset;
    'svelte/easing': Preset;
    'svelte/motion': Preset;
    'svelte/store': Preset;
    'svelte/transition': Preset;
    'vee-validate': Preset;
    vitepress: Preset;
    'vue-demi': Preset;
    'vue-i18n': Preset;
    'vue-router': Preset;
    vue: Preset;
    'vue/macros': Preset;
    vuex: Preset;
    vitest: Preset;
    'uni-app': Preset;
    'solid-js': Preset;
    'solid-app-router': Preset;
};
declare type BuiltinPresetName = keyof typeof builtinPresets;

declare type ModuleId = string;
declare type ImportName = string;
interface ImportCommon {
    /** Module specifier to import from */
    from: ModuleId;
    /**
     * Priority of the import, if multiple imports have the same name, the one with the highest priority will be used
     * @default 1
     */
    priority?: number;
    /** If this import is disabled */
    disabled?: boolean;
}
interface Import extends ImportCommon {
    /** Import name to be detected */
    name: ImportName;
    /** Import as this name */
    as?: ImportName;
}
declare type PresetImport = ImportName | [name: ImportName, as?: ImportName, from?: ModuleId] | Exclude<Import, 'from'>;
interface Preset extends ImportCommon {
    imports: (PresetImport | Preset)[];
}
interface UnimportContext {
    readonly imports: Import[];
    staticImports: Import[];
    dynamicImports: Import[];
    map: Map<string, Import>;
    addons: Addon[];
    invalidate(): void;
    resolveId(id: string, parentId?: string): Thenable<string | null | undefined | void>;
    options: Partial<UnimportOptions>;
}
interface AddonsOptions {
    /**
     * Enable auto import inside for Vue's <template>
     *
     * @default false
     */
    vueTemplate?: boolean;
}
interface UnimportOptions {
    imports: Import[];
    presets: (Preset | BuiltinPresetName)[];
    warn: (msg: string) => void;
    addons: AddonsOptions | Addon[];
    virtualImports: string[];
    /**
     * Custom resolver to auto import id
     */
    resolveId?: (id: string, importee?: string) => Thenable<string | void>;
}
declare type PathFromResolver = (_import: Import) => string | undefined;
interface ScanDirExportsOptions {
    /**
     * Glob patterns for matching files
     *
     * @default ['*.{ts,js,mjs,cjs,mts,cts}']
     */
    filePatterns?: string[];
    /**
     * Custom function to filter scanned files
     */
    fileFilter?: (file: string) => boolean;
    /**
     * Current working directory
     *
     * @default process.cwd()
     */
    cwd?: string;
}
interface TypeDeclarationOptions {
    /**
     * Custom resolver for path of the import
     */
    resolvePath?: PathFromResolver;
    /**
     * Append `export {}` to the end of the file
     *
     * @default true
     */
    exportHelper?: boolean;
}
interface InjectImportsOptions {
    /**
     * @default false
     */
    mergeExisting?: boolean;
    /**
     * If the module should be auto imported
     *
     * @default true
     */
    autoImport?: boolean;
    /**
     * If the module should be transformed for virtual modules.
     * Only available when `virtualImports` is set.
     *
     * @default true
     */
    transformVirtualImports?: boolean;
    /** @deprecated */
    transformVirtualImoports?: boolean;
}
declare type Thenable<T> = Promise<T> | T;
interface Addon {
    transform?: (this: UnimportContext, code: MagicString, id: string | undefined) => Thenable<MagicString>;
    declaration?: (this: UnimportContext, dts: string, options: TypeDeclarationOptions) => string;
    matchImports?: (this: UnimportContext, identifiers: Set<string>, matched: Import[]) => Thenable<Import[] | void>;
}

export { AddonsOptions as A, BuiltinPresetName as B, Import as I, ModuleId as M, Preset as P, ScanDirExportsOptions as S, TypeDeclarationOptions as T, UnimportOptions as U, Thenable as a, InjectImportsOptions as b, builtinPresets as c, ImportName as d, ImportCommon as e, PresetImport as f, UnimportContext as g, PathFromResolver as h, Addon as i };
